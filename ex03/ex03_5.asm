.data
	str_A:
			.asciz "A"	#  char = A , hex ASCII = 0x00000041 , binary ASCII = 01000001
			.align 2
	str_B:
			.asciz "B"	#  char = B , hex ASCII = 0x00000042 , binary ASCII = 01000010
			.align 2
	str_C:
			.asciz "C"	#  char = C , hex ASCII = 0x00000043 , binary ASCII = 01000011
			.align 2
	str_Z:
			.asciz "Z"	#  char = Z , hex ASCII = 0x0000005a , binary ASCII = 01011010
			.align 2
	str_a:
			.asciz "a"	#  char = a , hex ASCII = 0x00000061 , binary ASCII = 01100001
			.align 2
	str_b:
			.asciz "b"	#  char = b , hex ASCII = 0x00000062 , binary ASCII = 01100010
			.align 2
	str_c:
			.asciz "c"	#  char = c , hex ASCII = 0x00000063 , binary ASCII = 01100011
			.align 2
	str_z:
			.asciz "z"	#  char = z , hex ASCII = 0x0000007a , binary ASCII = 01111010
			.align 2
	str_zero:
			.asciz "0"	#  char = 0 , hex ASCII = 0x00000030 , binary ASCII = 00110000
			.align 2
	str_one:	
			.asciz "1"	#  char = 1 , hex ASCII = 0x00000031 , binary ASCII = 00110001
			.align 2
	str_two:
			.asciz "2"	#  char = 2 , hex ASCII = 0x00000032 , binary ASCII = 00110010
			.align 2
	str_nine:
			.asciz "9"	#  char = 9 , hex ASCII = 0x00000039 , binary ASCII = 00111001
			.align 2
			
			#Παρατηρώ πώς οι τιμές των χαρακτήρων,τόσο στο δεκαεξαδικό όσο και στο δυαδικό σύστημα,ξεκινούν τα LS bytes  να αποθηκεύονται στις μικρότερες διευθύνσεις της word της μνήμης
			#Αυτη η ομοιομορφία συμβαίνει επειδή ο RARS είναι little-Endian και αποθηκεύει το LS byte του "δεδομένου" στη μνήμη ξεκινόντας από την μικρότερη διεύθυνση και προχορώντας στα MS bytes τα αποθηκεύει σε θέσεις με μεγαλύτερη διεύθυνση  
			#Αφου τα LS byte στους little Endians  βρίσκονται στην μικρότερη διεύθυνση(κάθε word,έχει την διεύθηνση,στην οποία αποθηκεύεται το LS byte,και είναι η μικρότερη σε σχέση με τις διευθήνσεις των άλλων MS bytes)
			#Αν βρισκόμασταν σε Big Endian τo LS byte  του 'δεδομένου' θα ήταν αποθηκεύμενο στην μεγαλύτερη διεύθυνση ενώ το MS byte του θα ήταν αποθηκευμένο στην μικρότερη διεύθηνση 
						
			#Τελος,μια ακόμη παρατήρηση είναι πως ο επόμενος χαρακτήρας ενος χαρακτήρα(στο λατινικό αλφάβητο το επόμενο γράμμα και στους αριθμούς ο επόμενος αριθμός), η τιμή του στο ASCII είναι τιμή του πρώτου 
			#χαρακτήρα +1 στο δεκαεξαδικό.Το αντιστοιχο συμβαίνει και στη δυαική αναπαράσταση.Δηλαδή για παράδειγμα η δυαδικη αναπαράσταση του B είναι 01000010 ,που ειναι ισο αν 
			#κάναμε αύξηση της δυαδικης τιμής του Α κατα 1,για να δείχνει τον αμέσως επόμενο αριθμό.Ετσί μπορούμε , με τον κώδικα ASCII να μεταφερθούμε σε οποιο χαρακτήρα θέλουμε,
			#αν γνωρήζουμε σε ποιο χαρακτήρα βρισκόμαστε(Αν ειμαστε στο A και θέλουμε να πάμε στο C τότε θά αυξήσουμε την τιμή του κατα 2).
			#Στο ASCII επομένως παρατηρούμε την εξής ομοιομορφία:
			#Τα κεφαλαία λατινικά γράμματα ξεκινώντας απο το A και τελειώνοντας στο Z,εκφράζονται με αριθμους
			#Το A ειναι ο αριθμός 41 στο δεκαεξαδικό και αυξάνοντας κάθε φορα με 1 πάμε στο επόμενο γράμμα(Αν πχ θέλουμε να πάμε στο B
			#θα αυξήσουμε το A=41 κατα 1
			#δηλαδή 41+1=42,οπου 42=B).Ετσι συνεχίζει φτάνοντας στο Z το οποίο είναι το τελευταιο κεφαλαίο γράμμα και εκφράζται ως τον hex αριθμό 5a
			#Αντίστοιχα,τα μικρά λατινικά γράμματα ξεκινώντας απο το a και τελειώνοντας στο z,εκφράζονται με αριθμους
			#Το a ειναι ο αριθμός 61 στο δεκαεξαδικό και αυξάνοντας κάθε φορα με 1 πάμε στο επόμενο γράμμα(Αν πχ θέλουμε να πάμε στο b
			#θα αυξήσουμε το a=61 κατα 1
			#δηλαδή 61+1=62,οπου 62=b).Ετσι συνεχίζει φτάνοντας στο z το οποίο είναι το τελευταιο μικρό γράμμα και εκφράζται ως τον hex αριθμό 7a
			#Το,ίδιο συμβαίνεικαι με τους αριθμούς,οπου το 0 εκφράζεται ως τον αριθμό 30 στο δεκαεξαδικό και αυξάνοντας κάθε φορα με 1 πάμε στο επόμενο γράμμα φτάνοντας εν τέλη στο 39 το οποίο ειναι ο αριθμός 9(Τελος ενα παράδειγμα με αριθμούς,αν θέλουμε να πάμε στο 2 από το 0
			#θα αυξήσουμε το 0=30 κατα 2
			#δηλαδή 30+2=32,οπου 32=2).

			
			
			#α) Αν διαβάσουμε σε μια μηχανή Little Endian το null terminated string "xyz" ως έναν ακέραιο , τότε θα ξεκινήσουμε από την μικρότερη διεύθυνση του 32 μπιτου ακεραιου και θα 
			#προχωρήσουμε προς τις θέσεις με τις μεγαλύτερες διευθύνσεις .Θα ξεκινήσει να διαβάζει τα LS byte(θεωρεί οτι είναι ακέραιος) και θα προχωρεί προς τα MS byte του string.
			#Πρώτα θα διαβάσει το z(πρωτο byte,LS byte του ακεραιου) ,έπειτα το y(δεύτερο byte), μετά το x(3o byte,MS byte του ακεραιου) και τέλος τον null χαρακτήρα (\0,4ο byte του οπόιου ολα τα bits=0,που είναι σαν να μην υπάρχει)
			#Επομένως το z στο hex ASCII είναι 7a,το y στο hex ASCII είναι 79,το x στο hex ASCII είναι 78.Μετατρέποντας έτσι τον hex αριθμό 007a7978 σε δεκαδικό,θα έχουμε
			# (0 * 16^7) + (0 * 16^6) + (7 * 16^5) + (10 * 16^4) + (7 * 16^3) + (9 * 16^2) + (7 * 16^1) + (8 * 16^0) = 8026488
			
			#β) Αν διαβάσουμε σε μια μηχανή Big Endian το null terminated string "xyz" ως έναν ακέραιο , τότε θα ξεκινήσουμε από την μικρότερη διεύθυνση του 32 μπιτου ακεραιου και θα 
			#προχωρήσουμε προς τις θέσεις με τις μεγαλύτερες διευθύνσεις .Δεδομένου οτι οι Big Endian αποθηκεύουν το LS byte του 'δεδομένου' στην μεγαλύτερη διεύθυνση του,και τo MS byte του στην μικρότερη διεύθυνση, πρώτα θα διαβάσει 
			#το x στο hex ASCII που είναι 78(MS byte του ακεραιου),το y στο hex ASCII είναι που 79,το z στο hex ASCII είναι 7a,και τελος το null χαρακτήρα '\0'(LS byte του ακεραιου).Μετατρέποντας έτσι τον hex αριθμό 78797a00 σε δεκαδικό,θα έχουμε
			#(7 * 16^7) + (8 * 16^6) + (7 * 16^5) + (9 * 16^4) + (7 * 16^3) + (10 * 16^2) + (0 * 16^1) + (0 * 16^0) = 2021227008
			
			
			
	str_ex03:
			.asciz "xyz"
.text
		  	lw x20,str_ex03 #load the address of the xyz string into the x20 register
		  	addi x17,x0,1 #environment call code for print_int
		  	add  x10,x0,x20 #put the string address into x10 register
		  	ecall
